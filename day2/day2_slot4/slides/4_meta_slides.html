<!DOCTYPE html>
<html>
  <head>
    <title>Representation learning, interpretability, and uncertainty</title>
    <meta charset="utf-8">
    <meta name="author" content="Sigrid Keydana" />
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Representation learning, interpretability, and uncertainty
## A pick of ‘meta’ topics in current DL
### Sigrid Keydana
### RStudio::conf 2019

---








# Representation learning, interpretability, and uncertainty

What do these topics have in common?

--

- Terms are not necessarily well-defined
- We'll keep out of terminology-related controversies, and
- Focus on the code

--

The idea being: Enable you to apply what's useful to you _in your area of work/interest_

---
class: inverse, middle, center

# Representation learning


---

# Why representation learning?

- Representation matters&lt;sup&gt;1&lt;/sup&gt;
- Good representations make subsequent prediction task easier 
- Make use of abundant unlabeled data (unsupervised pretraining)
- Transfer learning / domain adaptation
- Density estimation
- Object generation




.footnote[[1] cf. Goodfellow, Bengio, and Courville (2016), chap. 15, and Bengio, Courville, and Vincent (2012).]

---

## Variational autoencoders (VAEs)

- often used in object generation
- learn a _latent space_ that can be sampled from
- learning objective is a tradeoff between faithful input reconstruction and conforming to a (regularizing) prior
- Minimize: Evidence lower bound (ELBO)

`$$ELBO\ = \ E[log\ p(x|z)]\ -\ KL(q(z)||p(z))$$`

--

#### Problems with traditional VAEs

- may learn uninformative latent space
- tends to overfit the data

---

# InfoVAE and subtypes

- designed to learn more meaningful features
- e.g. by maximizing mutual information between latent space prior and posterior
- we'll see a subtype (MMD-VAE) soon

--

But before, we need some background on

---
class: inverse, middle, center

# Eager execution


---

# Eager execution

- The non-graph way of doing TensorFlow/Keras
- More intuitive than static Keras/TF especially if not following the usual define-compile-fit cycle:
  - encoder-decoder models (as in GANs, VAEs ...)
  - neural style transfer
  - models with attention mechanisms
  
--

#### Detailed examples on the TensorFlow for R blog:

- [More flexible models with TensorFlow eager execution and Keras](https://blogs.rstudio.com/tensorflow/posts/2018-10-02-eager-wrapup/)
- [Image-to-image translation with pix2pix](https://blogs.rstudio.com/tensorflow/posts/2018-09-20-eager-pix2pix/)
- [Attention-based Image Captioning with Keras](https://blogs.rstudio.com/tensorflow/posts/2018-09-17-eager-captioning/)
- [Neural style transfer with eager execution and Keras](https://blogs.rstudio.com/tensorflow/posts/2018-09-10-eager-style-transfer/)
- [Generating images with Keras and TensorFlow eager execution](https://blogs.rstudio.com/tensorflow/posts/2018-08-26-eager-dcgan/)
- [Attention-based Neural Machine Translation with Keras](https://blogs.rstudio.com/tensorflow/posts/2018-07-30-attention-layer/)


---

# Eager execution exercise

- demo: [eager_intro.Rmd](../notebooks/eager_intro.Rmd)
- exercise: [4_meta_quizzes.Rmd](../exercises/4_meta_quizzes.Rmd)


---
class: inverse, middle, center

# Variational autoencoder (MMD-VAE)


---

# Representation learning with MMD-VAE

- Idea described in _InfoVAE: Information Maximizing Variational Autoencoders_&lt;sup&gt;1&lt;/sup&gt;

- Read up later here: [Representation learning with MMD-VAE](https://blogs.rstudio.com/tensorflow/posts/2018-10-22-mmd-vae)

- Complete code here: [mmd_cvae.R](https://github.com/rstudio/keras/blob/master/vignettes/examples/mmd_cvae.R)

- We'll take a bird's view here, not going into every detail



.footnote[[1] cf. Zhao, Song, and Ermon (2017)]

---
# MMD-VAE, main steps (1): data streaming


```r
library(keras)
use_implementation("tensorflow")
library(tensorflow)
tfe_enable_eager_execution(device_policy = "silent")

library(tfdatasets)
# also load dplyr, ggplot2, glue

fashion &lt;- dataset_fashion_mnist()
c(train_images, train_labels) %&lt;-% fashion$train
c(test_images, test_labels) %&lt;-% fashion$test

train_x &lt;- train_images %&gt;% `/`(255) %&gt;%
  k_reshape(c(60000, 28, 28, 1))

test_x &lt;- test_images %&gt;% `/`(255) %&gt;%
  k_reshape(c(10000, 28, 28, 1))

buffer_size &lt;- 60000
batch_size &lt;- 100

*train_dataset &lt;- tensor_slices_dataset(train_x) %&gt;%
*  dataset_shuffle(buffer_size) %&gt;%
*  dataset_batch(batch_size)
```

---
# MMD-VAE, main steps (2): encoder model


```r
encoder_model &lt;- function(name = NULL) {
  keras_model_custom(name = name, function(self) {
*    self$conv1 &lt;- 
*      layer_conv_2d(             # actually a convolutional encoder
        filters = 32,
        kernel_size = 3,
        strides = 2,
        activation = "relu")
     self$conv2 &lt;-
      layer_conv_2d(
        filters = 64,
        kernel_size = 3,
        strides = 2,
        activation = "relu")
    self$flatten &lt;- layer_flatten()
*   self$dense &lt;- layer_dense(units = latent_dim)     # 2 for easy viz
    function (x, mask = NULL) {
      x %&gt;%
        self$conv1() %&gt;%
        self$conv2() %&gt;%
        self$flatten() %&gt;%
        self$dense()
      }})}
```


---
# MMD-VAE, main steps (3): decoder model



```r
decoder_model &lt;- function(name = NULL) {
  
  keras_model_custom(name = name, function(self) {
    self$dense &lt;- layer_dense(units = 7 * 7 * 32, activation = "relu")
    self$reshape &lt;- layer_reshape(target_shape = c(7, 7, 32))
*    self$deconv1 &lt;- # first of 3 up-convolutions
      layer_conv_2d_transpose(
        filters = 64,
        kernel_size = 3,
        strides = 2,
        padding = "same",
        activation = "relu"
      )
*  self$deconv2 &lt;-  # another conv_2d_transpose, filters=32
*  self$deconv3 &lt;-  # another conv_2d_transpose, filters=1
    function (x, mask = NULL) {
      x %&gt;%
        self$dense() %&gt;%
        self$reshape() %&gt;%
        self$deconv1() %&gt;%
        self$deconv2() %&gt;%
        self$deconv3()
    }
  })}
```

---
# MMD-VAE, main steps (4): MMD loss

The loss, _maximum mean discrepancy_ (MMD), is based on the idea that two distributions are identical if and only if all moments are identical. 

Concretely, MMD is estimated using a _kernel_, such as the Gaussian kernel

`$$k(z,z')=\frac{e^{||z-z'||}}{2\sigma^2}$$`

to assess similarity between distributions.

The idea then is that if two distributions are identical, the average similarity between samples from each distribution should be identical to the average similarity between mixed samples from both distributions:

`$$MMD(p(z)||q(z))=E_{p(z),p(z')}[k(z,z')]+E_{q(z),q(z')}[k(z,z')]−2E_{p(z),q(z')}[k(z,z')]$$`

---
# MMD-VAE, main steps (4): MMD loss



```r
compute_kernel &lt;- function(x, y) {
  x_size &lt;- k_shape(x)[1]
  y_size &lt;- k_shape(y)[1]
  dim &lt;- k_shape(x)[2]
  tiled_x &lt;- k_tile(
    k_reshape(x, k_stack(list(x_size, 1, dim))),
    k_stack(list(1, y_size, 1))
  )
  tiled_y &lt;- k_tile(
    k_reshape(y, k_stack(list(1, y_size, dim))),
    k_stack(list(x_size, 1, 1))
  )
  k_exp(-k_mean(k_square(tiled_x - tiled_y), axis = 3) /
          k_cast(dim, tf$float64))
}

compute_mmd &lt;- function(x, y, sigma_sqr = 1) {
  x_kernel &lt;- compute_kernel(x, x)
  y_kernel &lt;- compute_kernel(y, y)
  xy_kernel &lt;- compute_kernel(x, y)
  k_mean(x_kernel) + k_mean(y_kernel) - 2 * k_mean(xy_kernel)
}
```


---
# MMD-VAE, main steps (5): training loop


```r
for (epoch in seq_len(num_epochs)) {
  iter &lt;- make_iterator_one_shot(train_dataset)
  until_out_of_range({
    x &lt;-  iterator_get_next(iter)
    with(tf$GradientTape(persistent = TRUE) %as% tape, {
      mean &lt;- encoder(x)
      preds &lt;- decoder(mean)
      true_samples &lt;- k_random_normal(
        shape = c(batch_size, latent_dim), dtype = tf$float64)
*    loss_mmd &lt;- compute_mmd(true_samples, mean)
*      loss_nll &lt;- k_mean(k_square(x - preds))
*      loss &lt;- loss_nll + loss_mmd
    })
    encoder_gradients &lt;- tape$gradient(loss, encoder$variables)
    decoder_gradients &lt;- tape$gradient(loss, decoder$variables)
    optimizer$apply_gradients(purrr::transpose(list(
      encoder_gradients, encoder$variables
    )),
    global_step = tf$train$get_or_create_global_step())
    optimizer$apply_gradients(purrr::transpose(list(
      decoder_gradients, decoder$variables
    )),
    global_step = tf$train$get_or_create_global_step())
  })}
```


---
# MMD-VAE: Generated images

![](images/mmd_clothes_epoch_50.png)


---
# MMD-VAE: Latent space

![](images/mmd_latentspace_epoch_50.png)

---
# MMD-VAE: Interpolations

![](images/mmd_grid_epoch_50.png)


---
# Variational autoencoders: Exercise

- exercise: [4_meta_quizzes.Rmd](../exercises/4_meta_quizzes.Rmd)


---
class: inverse, middle, center

# Interpretability

---
# Interpretability/explainability

- Everybody wants it but it's actually not a well-defined term
- Commonly, a division is made between _interpreting a model_ and _explaining model decisions_
- But see e.g. "The Mythos of Model Interpretability"&lt;sup&gt;1&lt;/sup&gt; for the lack of agreed-upon definitions
- Here, we'll skip any theoretical discussion and focus on two different ways of _local explanations_
- Just one quote on the theory before we leave that be&lt;sup&gt;2&lt;/sup&gt;

&gt; However, it is
fair to say that most work in explainable artificial intelligence uses only the researchers’
intuition of what constitutes a ‘good’ explanation.  There exists vast and valuable bodies
of research in philosophy, psychology, and cognitive science of how people define, generate, select, evaluate, and present explanations, which argues that people employ certain
cognitive  biases  and  social  expectations  towards  the  explanation  process. 




.footnote[[1] cf. Lipton (2016)

[2] cf. Miller (2017)]

---
# LIME&lt;sup&gt;1&lt;/sup&gt;

.pull-left[![](images/lime1.png)]
.pull-right[![](images/lime2.png)]




.footnote[[1] cf. Ribeiro, Singh, and Guestrin (2016)]


---
# LIME on images

- Uses obfuscation on differently-sized _superpixels_
- As LIME works by switching presence of superpixels on and off, obtaining an explanation for a high-res image can take some time
- We will thus resize images before passing them to LIME as anyway the model will work with that size


---
# LIME (1): Create an explainer

##### We first create an _explainer_ using the `lime` factory function


```r
# the first argument is the path to the image
# the second argument should indicate to LIME the type of model
# the third argument is a preprocessing function we need to define

explainer &lt;- lime(img_path, as_classifier(model, labels), image_prep)
```


##### And here's the preprocessing function that has to be passed to `lime`


```r
image_prep &lt;- function(x) {
  arrays &lt;- lapply(x, function(path) {
    img &lt;- image_load(path, target_size = c(224,224)) %&gt;%
      image_to_array()
    img &lt;- img %&gt;%
      array_reshape(c(1, dim(img))) %&gt;%
      imagenet_preprocess_input()
  })
  do.call(abind::abind, c(arrays, list(along = 1)))
}
```


---
# LIME(2): Get a prediction

##### This also allows to test the preprocessing function


```r
preds &lt;- predict(model, image_prep(img_path))
```

##### Decode prediction


```r
preds %&gt;% imagenet_decode_predictions()
```

```
  class_name   class_description      score
1  n02782093           balloon    9.999470e-01
2  n03888257         parachute    3.710761e-05
3  n02692877           airship    1.597529e-05
4  n04562935       water_tower    4.031146e-08
5  n04507155          umbrella    2.227399e-08
```

---
# LIME (3): Explore superpixels

##### Explore different settings for number of superpixels before actually getting an explanation:


```r
plot_superpixels(img_path, colour = "cyan",
                 n_superpixels = 50, weight = 10)
plot_superpixels(img_path, colour = "cyan",
                 n_superpixels = 200, weight = 10)
```

![Using 50 vs. 200 superpixels](images/superpixels.png)


---
# LIME (4): Get explanation

##### Call `explain` with the path to the image, the `explainer`, and optional parameters:


```r
explanation &lt;- explain(
  img_path, 
  explainer,
  n_labels = 1, 
  n_features = 200,
  n_superpixels = 200,
  weight = 20)
```


```r
plot_image_explanation(explanation, fill_alpha = 0.6)
plot_image_explanation(explanation, display = "block", block_col = "violet")
```

![2 of several ways to display an explanation](images/explanations.png)


---
# LIME: Exercise

- demo: [lime.Rmd](../notebooks/eager_intro.Rmd) (not needed for this exercise)
- exercise: [4_meta_quizzes.Rmd](../exercises/4_meta_quizzes.Rmd)


---
# Class activation maps (CAM)

- For a given input image, class activation maps take the __output feature maps__ of a convolution layer and __weigh__ every channel in that feature map by the __gradient of the most probable class__ with respect to the channel.

- Meaning: How much would that class probability change if that channel's activations were to change?


---
# CAM (1): Get the most probable class


```r
preds &lt;- model %&gt;% predict(img)
max_pred &lt;- which.max(preds[1,])

image_output &lt;- model$output[, max_pred]
```

We will want to compute this class output's gradient with respect to the activations of all channels in the last conv layer.

---
# CAM (2): Get the last conv layer's output


```r
last_conv_layer &lt;- model %&gt;% get_layer("block5_conv3")
last_conv_layer_output &lt;- last_conv_layer$output
```

These are the activations w.r.t. which we want to compute the class probability's gradient.

---
# CAM (3): Fetch the pooled gradients


We build a little graph to fetch and average the gradients - and run it.


```r
grads &lt;- k_gradients(image_output, last_conv_layer_output)[[1]]
# average gradients over all but the channel dimension
pooled_grads &lt;- k_mean(grads, axis = c(1, 2, 3))

iterate &lt;- k_function(
  list(model$input),
  list(pooled_grads, last_conv_layer_output[1, , , ])
)

c(pooled_grads_value, conv_layer_output_value) %&lt;-% iterate(list(img))
```


---
# CAM (4): Multiply outputs by channel gradients

This weights up the channels that have high impact on the classification.


```r
for (i in 1:512) {
  conv_layer_output_value[ , , i] &lt;- 
    conv_layer_output_value[ , , i] * pooled_grads_value[i] 
}
```

Averaging over the channels dimension yields the heatmap:



```r
heatmap &lt;- apply(conv_layer_output_value, c(1,2), mean)
```

---
# CAM (5): Heatmap (overlayed over image)

![](images/cam.png)

---
# References

Bengio, Y, A. C. Courville and P. Vincent (2012). "Unsupervised
Feature Learning and Deep Learning: A Review and New
Perspectives". In: _CoRR_ abs/1206.5538. eprint: 1206.5538. URL:
[http://arxiv.org/abs/1206.5538](http://arxiv.org/abs/1206.5538).

Goodfellow, I, Y. Bengio and A. Courville (2016). _Deep Learning_.
MIT Press. URL:
[http://www.deeplearningbook.org](http://www.deeplearningbook.org).

Lipton, Z. C. (2016). "The Mythos of Model Interpretability". In:
_CoRR_ abs/1606.03490. eprint: 1606.03490. URL:
[http://arxiv.org/abs/1606.03490](http://arxiv.org/abs/1606.03490).

Miller, T. (2017). "Explanation in Artificial Intelligence:
Insights from the Social Sciences". In: _CoRR_ abs/1706.07269.
eprint: 1706.07269. URL:
[http://arxiv.org/abs/1706.07269](http://arxiv.org/abs/1706.07269).

Ribeiro, M. T, S. Singh and C. Guestrin (2016). ""Why Should I
Trust You?": Explaining the Predictions of Any Classifier". In:
_CoRR_ abs/1602.04938. eprint: 1602.04938. URL:
[http://arxiv.org/abs/1602.04938](http://arxiv.org/abs/1602.04938).

Zhao, S, J. Song and S. Ermon (2017). "InfoVAE: Information
Maximizing Variational Autoencoders". In: _CoRR_ abs/1706.02262.
eprint: 1706.02262. URL:
[http://arxiv.org/abs/1706.02262](http://arxiv.org/abs/1706.02262).
    </textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "solarized",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function() {
  var d = document, s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})();</script>

<script>
(function() {
  var i, text, code, codes = document.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
})();
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
